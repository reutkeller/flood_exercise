# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06train_ml.ipynb.

# %% auto 0
__all__ = ['classification_pixels']

# %% ../nbs/06train_ml.ipynb 4
import rasterio
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
# import geopandas as gpd
# import matplotlib.pyplot as plt


from . import utils_func
from . import const_vals as CONST

# %% ../nbs/06train_ml.ipynb 5
class classification_pixels():
  
  def __init__(self,
               path_labels_str : str , #path to the labeled images
               path_imgs_str : str , #path to S2 images to be used for train
               target_col : str , #name of the target attribute in the dataframe. Will be used for model training
               cols_to_drop : list = [None] , # list of columns to be dropped from the dataframe. These columns won't be used to train the model. 
               test_size : float=CONST.TEST_SIZE , #size of test data
               random_state : int = CONST.RANDOM_STATE , #random state , deafult value is set in Cconst_vals module
               ):
    
    self.target_col = target_col
    self.cols_to_drop = cols_to_drop
    self.test_size = test_size
    self.random_state = random_state
    
    self.path_labels = utils_func.load_list_paths(path = path_labels_str , filter_file = True)
    self.path_imgs = utils_func.load_list_paths(path = path_imgs_str , filter_file= True)

    dfs_pixels = []
    for label_path in self.path_labels:
      id_path = label_path.split(CONST.SPLIT_TILES_NAMES_STR1)[-1].split(CONST.SPLIT_TILES_NAMES_STR2)[1]
      
      #find the matching S2 image
      s2_img_path = [x for x in self.path_imgs if id_path in x]
      
      if len(s2_img_path)==1:

        s2_img = rasterio.open(s2_img_path[0]).read()
        cols = rasterio.open(s2_img_path[0]).descriptions + rasterio.open(label_path).descriptions
        cols = [str(x) for x in cols]
        label_img = rasterio.open(label_path).read()
        

        # Stack the imags 
        stacked_img = np.concatenate((s2_img, label_img), axis=0)
        
        df_pixels = pd.DataFrame(stacked_img.reshape([stacked_img.shape[0],-1]).T)
        df_pixels.columns = cols
        dfs_pixels.append(df_pixels)

      else:
        continue

    self.df_res = pd.concat(dfs_pixels)
    

    self._prepare_dataframe_for_train_()

    self.x_train, self.x_test, self.y_train, self.y_test = self._prepare_dataframe_for_train_()


  
  def _prepare_dataframe_for_train_(self):
    

    if self.cols_to_drop[0] != None :
      self.cols_to_drop=self.df_res.drop(self.cols_to_drop,axis=1)

    #drop null values
    self.df_res.dropna(inplace=True)

    x = self.df_res.drop(self.target_col,axis=1)
    y = self.df_res[self.target_col].values
    print('I have x and y')
    

    x_train, x_test, y_train, y_test = train_test_split(x, y, 
                                                        test_size = self.test_size, 
                                                        random_state = self.random_state)

    return x_train, x_test, y_train, y_test
    


    
